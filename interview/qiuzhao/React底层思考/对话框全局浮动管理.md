# 对话框 浮动层 页面思想实现
## 将对话框从组件级别提升到应用级别，通过全局状态管理实现
- 定义一个对话框的时候，其定位基本会等价于定义一个具有唯一 URL 路径的页面
- 定义一个 useNiceModal 这样的 Hook，在其内部封装对 Store 的操作，从而实现对话框状态管理的逻辑重用，并以更友好的方式暴露给用户

- 传统对话框管理存在的问题：
    组件层级混乱：不知道在哪个层级定义对话框
    状态管理复杂：每个对话框都要单独管理显示/隐藏状态
    重复代码：相似的对话框逻辑在各处重复
- 解决思路：全局状态管理
    核心理念：把对话框当作"页面"来管理
    对话框 ≈ 独立的页面（只是用弹层实现而非路由切换）
    每个对话框有唯一 ID（类似 URL 路径）
    全局状态管理所有对话框（类似路由管理）
- 页面有唯一 URL → 对话框有唯一 ID
  路由管理页面切换 → 全局状态管理对话框显示/隐藏
- 可以先看下数据链路，再想想代码怎么写：“
```js
点击按钮 
→ modal.show({ userId: 123 }) 
→ dispatch Redux action 
→ Redux state 更新为 { 'user-modal': { userId: 123 } },状态共享
→ UserModal 组件重新渲染，UI 更新
→ useNiceModal 检测到 visible = true，控制器，隐藏或者显示
→ 渲染 RealUserModal 组件
→ 对话框显示
```

```js
// useNiceModal hooks 封装redux 等状态管理

// 第一步：定义具体的对话框组件，NiceModal 可复用组件，可以是自定义也可以是第三方
function RealUserModal({ userId }) {
  return (
    <NiceModal id="user-modal">
      <div>用户ID: {userId}</div>
    </NiceModal>
  );
}

// 第二步：用 create 包装成可控制的组件
const UserModal = NiceModal.create('user-modal', RealUserModal);

// 第三步：在应用中渲染（关键！）
function App() {
  return (
    <div>
      <SomeComponent />
      <UserModal />  {/* 必须渲染，否则对话框不会显示 */}
    </div>
  );
}

// 第四步：在任意组件中控制
function SomeComponent() {
  const modal = useNiceModal('user-modal');
  return (
    <button onClick={() => modal.show({ userId: 123 })}>
      打开对话框
    </button>
  );
}
```

## useSelector(s => !!s[modalId]) 解析
- 核心：使用 useSelector 钩子从 Redux 状态树中获取对话框的显示状态
- 参数：modalId 对话框的唯一标识符，s[modalId] 获取对应对话框的状态值
- 返回值：布尔值，表示对话框是否显示，*!! 是双重否定，将任何值转为布尔值*
```js
// 如果 state = { 'user-modal': { userId: 123 } }
// 那么 s['user-modal'] = { userId: 123 }
// !!{ userId: 123 } = true
```

### 处理对话框返回值
-  show 和 resolve 两个函数通过 Promise 联系起来
**使用 Promise + 回调函数缓存机制**
- 调用者传参给对话框，对话框返回结果给调用者
```js
// 伪代码：完整的数据流
1. 用户点击"编辑"按钮
   → handleEdit(user) 执行 

2. 调用 modal.show({ user }) 
   → 创建 Promise
   → 将 resolve 函数存储到 modalCallbacks['edit-user-modal']
   → dispatch 显示对话框
   → 返回 Promise（await 在这里等待）

3. 对话框显示，用户输入数据

4. 用户点击"确定"
   → handleConfirm() 执行
   → modal.resolve(formData) 执行
   → 从 modalCallbacks 中取出之前存储的 resolve 函数
   → 执行 resolve(formData)
   → Promise 完成，await 得到 formData

5. UserList 组件收到返回值
   → 更新表格数据
```
```js
// 伪代码：返回值处理的核心机制
const modalCallbacks = {};  // 全局缓存，存储每个对话框的 resolve 函数

export const useNiceModal = (modalId) => {
  const show = useCallback((args) => {
    return new Promise((resolve) => {
      // 1. 将 resolve 函数存储到全局缓存 id 区分不同对话框
      modalCallbacks[modalId] = resolve;
      
      // 2. 显示对话框 
      dispatch(showModal(modalId, args));
      
      // 3. 返回 Promise，调用者可以用 await 等待结果
    });
  }, [modalId]);

  const resolve = useCallback((result) => {
    // 4. 对话框内部调用 resolve 时，触发之前缓存的回调
    if (modalCallbacks[modalId]) {
      modalCallbacks[modalId](result);  // 执行 Promise 的 resolve
      delete modalCallbacks[modalId];   // 清理缓存，确保只能 resolve 一次[⏰]
    }
  }, [modalId]);

  return { show, resolve, hide, visible };
};
```
```js
// 伪代码：表格组件调用对话框并等待返回值
function UserList() {
  const [users, setUsers] = useState([]);
  const modal = useNiceModal('edit-user-modal');

  const handleEdit = async (user) => {
    try {
      // 显示对话框并等待用户输入
      const updatedUser = await modal.show({ user });
      
      // 对话框返回后，更新表格数据
      setUsers(prev => 
        prev.map(u => u.id === user.id ? updatedUser : u)
      );
    } catch (error) {
      // 用户取消或其他错误处理
    }
  };

  return (
    <table>
      {users.map(user => (
        <tr key={user.id}>
          <td>{user.name}</td>
          <td>
            <button onClick={() => handleEdit(user)}>
              编辑
            </button>
          </td>
        </tr>
      ))}
    </table>
  );
}
```
```js
// 伪代码：对话框组件处理用户输入并返回结果
function EditUserModal() {
  const modal = useNiceModal('edit-user-modal');
  const [formData, setFormData] = useState({});

  const handleConfirm = () => {
    // 用户点击确定时，将表单数据返回给调用者
    modal.resolve(formData);  // 这里触发 Promise 的 resolve
    modal.hide();
  };

  const handleCancel = () => {
    modal.resolve(null);  // 取消时返回 null
    modal.hide();
  };

  return (
    <NiceModal id="edit-user-modal">
      <form>
        <input 
          value={formData.name}
          onChange={(e) => setFormData({...formData, name: e.target.value})}
        />
        <button onClick={handleConfirm}>确定</button>
        <button onClick={handleCancel}>取消</button>
      </form>
    </NiceModal>
  );
}
```