# 按需加载分包与Service Worker 缓存
## 如何控制好整个应用的大小，以及如何提升加载性能，才能确保应用的打开速度够快
- 根据统计显示，如果首页打开时间超过3秒，那么就会流失掉40%的用户
- 按需加载，只下载与页面相关的部分
- import是作为一个函数动态运行的，这个 import() 函数会返回一个 Promise。
这样，在模块加载成功后，我们就可以在 Promise 的 then 回调函数中去使用这个模块了
- 该在哪个位置使用 import 语句去定义动态加载的拆分点
*按业务模块为目标去做隔离，尽量在每个模块的起始页面去定义这个拆分点*

## 使用 react-lodable，实现组件的异步加载
```jsx
import Loadable from "react-loadable";
// 创建一个显示加载状态的组件
function Loading({ error }) {
  return error ? 'Failed' : 'Loading';
}
// 创建加载器组件
const HelloLazyLoad = Loadable({
  loader: () => import("./RealHelloLazyLoad"),
  loading: Loading,
});
```
- react-lodable 本身是通过高阶组件来实现的，这个高阶组件实现了模块加载、loading 状态以及错误处理的功能。你只要通过它提供的简单 API，就可以很容易实现组件的动态加载。
- 在代码中，我们可以看到 Loadable 这个`高阶组件`主要就是两个 API。
  - loader：用于传入一个加载器回调，在组件渲染到页面时被执行。在这个回调函数中，我们只需要直接使用 import 语句去加载需要的模块就可以了。
  - loading：表示用于显示加载状态的组件。在模块加载完成之前，加载器就会渲染这个组件。如果模块加载失败，那么 react-loadable 会将 errors 属性传递给 Loading 组件，方便你根据错误状态来显示不同的信息给用户。

## service worker 
- Service Worker 还提供了拦截前端请求的能力，使得它能够结合 Local Storage，成为一个独立的缓存方案。所以它不仅可以用于实现前端静态资源的缓存，还能用来开发离线的Web应用
- `Service Worker 会拦截所有浏览器发送出来的请求，你可以通过代码去控制 Rest API 这些请求发送到服务器；而 JS、CSS 等静态资源，则通过 Cache Storage 存储在浏览器端`
- 和浏览器自动的资源缓存机制相比，Service Worker 加上 Cache Storage 这个缓存机制，
具有更高的准确性和可靠性:
  - 缓存永远不过期。你只要下载过一次，就永远不需要再重新下载，除非主动删除。
  - 永远不会访问过期的资源。换句话说，如果发布了一个新版本，那么你可以通过版本化的一些机制，来确保用户访问到的一定是最新的资源
### 要使用 Service Worker，基本上分为注册、初始化、拦截请求等步骤
- 注册 Service Worker
```js
if ('serviceWorker' in navigator) {
  navigator.serviceWorker
    .register('/sw.js')
    .then(() => {
      // 注册成功
      console.log('Service worker registered.');
    }, (err) => {
      // 注册失败
      console.log('ServiceWorker registration failed: ', err);
    });
}
```
从代码中可以看到，首先我们需要判断当前浏览器是否支持 Service Worker。如果支持，那么就用 register 方法注册一个 Service Worker，它的参数是 Service Worker 脚本的代码路径，例子中的代码路径就是根路径下的 sw.js 这个文件。如果浏览器不支持，则什么都不做。
- 初始化 Cache Storage
  专门用于缓存一个请求的 request 和 response 的配对关系
  页面其实都会调用 Service Worker 的 register 方法去注册。
  但是浏览器会判断脚本内容是否有变化，只有发生了变化才会重新安装
```js
const cacheName = 'my_app_cache';
// 在 sw.js 中监听安装完成事件
self.addEventListener('install', function(e) {
  console.log('Service worker installed.');
  // 初始化 Cache Storage
  const cacheOpenPromise = caches.open(cacheName);
  // 安装过程中，等待 Cache Storage 配置完成
  e.waitUntil(cacheOpenPromise);
});
```
- 拦截请求
   sw.js 中使用fetch 或者axios 等处理
```js
// 监听所有的请求
self.addEventListener('fetch', function(e) {
  // 如果请求的路径不是 js 结尾，就通过 return false 来告诉 
  // service worker 这个请求应该发送到服务器端
  if (!request.url.endsWith('.js')) return false;
  
  // 否则检查 cache 中是否有对应的 response
  const promise = caches.open(cacheName).then(cache => {
    // 使用 cache.match 
    return cache.match(e.request).then(res => {
      if (res) {
        // 如果缓存存在则直接返回结果
        return Promise.resolve(res);
      } else {
        // 否则发出请求，并存到 cache
        const req = new Request(e.request.url);
        return fetch(corsRequest).then(res => {
          // 更新 cache
          cache.put(request, res.clone());
          return res;
        })
      }
    });
  });
  // 使用 e.respondWith 方法给请求返回内容
  e.respondWith(promise);
});
在这段代码中，采用的是一种缓存优先的策略。如果发现缓存存在，就使用缓存。否则发送请求到服务器端，然后把响应存放到缓存，并同时返回给调用者。
```