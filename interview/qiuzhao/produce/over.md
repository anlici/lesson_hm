## 提问promt
- 你是资深字节公司前端面试官，我是前端实习生。这是我的简历，两个项目。你可以对项目进行提问，每个项目点如果连续深度提问，不能超过3个问题。并且提出的问题不能太偏。
- 面试官，问题是一个个提出的，然后我回答，你对我的回答进行点评，并且提出下一个问题。因为我的回答可能准确，所以你需要客观并且有深度和广度的点评，如果你觉得某个简历项目描述不准确，也请指出来。
- 你就是面试官哦，不能帮我回答问题。我回答，我会把我的答案告诉你，然后你执行后续点评操作和新的针对性问题。问题是一个个提出的哦。

## 门户系统的主题切换机制
这个门户系统采用了配置驱动 + CSS变量的主题切换方案。首先，主题配置有三个数据源：代码中的默认配置、后端接口返回的应用配置、以及运行时的Context配置，按优先级合并。然后通过CSS变量系统实现主题的实际应用 - 我们在SCSS中定义了--navbar-bg-color、--sidebar-bg-color等变量，不同主题就是不同的变量值集合，比如:root是默认主题，.theme-blue是蓝色主题。当用户切换环境或应用时，系统会调用setTheme函数更新当前的主题配置，然后通过setPortalConfig动态修改CSS变量的值，所有使用这些变量的组件（面包屑、侧边栏、导航栏）会自动应用新主题样式。最巧妙的是，所有组件都通过React Context获取主题配置，完全不需要单独处理主题逻辑，实现了真正的配置化主题切换。这样设计的好处是新增主题只需要添加CSS变量定义，组件代码完全不用改，而且支持运行时实时切换，用户体验很流畅。


## 怎么结合路由来做代码分割的吗？用了哪些技术或工具？
- 意识到一次性打包所有路由会导致体积大、启动慢的问题
- 知道通过路由按需加载（代码分割）来解决，将代码分割成多个包，只在需要时加载对应资源
- 代码分割是借助打包工具 Vite 的能力,`将不同路由对应的组件模块拆分成单独的 chunk，`[对动态导入有这个能力] React.lazy 是在应用层面触发这种按需加载的机制`

### 加载失败的情况是怎么处理的，或者在服务端渲染（SSR）场景下有什么需要注意的地方？
- suspense 核心处理加载中状态切换，而错误（比如网络中断到chunk加载失败）则需要错误处理
- 错误处理：配合 Error Boundary（错误边界）：用 React.lazy 加载组件，外层用 Suspense 处理加载中，再套一层 ErrorBoundary 捕获加载失败，在 fallback 中显示错误提示或重试按钮

- SSR：务器渲染时只输出首屏必要 HTML，`客户端根据路由动态加载对应 chunk（比如 Next.js 的dynamic导入）js 激活后才渲染`

### 根据路由层级（比如/user/*相关路由打包到同一个 chunk）进行更精细的代码分割，Vite 中可以怎么配置
- 比如某些跨文件夹的组件，逻辑上属于同一路由模块，但物理路径分散，靠文件夹难以聚合。
- Vite 本身基于 Rollup 做打包，所以可以通过 Rollup 的【output.manualChunks 】配置，结合路由规则来手动指定 chunk 分组。

## 用 Vite 时，有没有遇到过 “动态导入的 chunk 加载后，状态丢失” 的问题？
- 原因：状态没有跳出局部
  - 局部状态：函数组件的 useState 是局部状态，组件重新挂载（动态导入后组件重新渲染）时，局部状态会被重置。比如一个动态加载的弹窗组件，用 useState 维护弹窗显隐，每次动态加载后，状态会回到初始值
  - 状态库作用域：在mobx，比如动态组件不在 Provider 包裹的范围内，无法获取全局状态。
  - 路由切换导致的组件卸载 / 重新挂载
    结合路由的动态导入，路由切换时组件被卸载再重新挂载，组件自身的局部状态自然会丢失（类组件的 state、函数组件的 useState 都会重置）。
- 解决：
  - 推荐：把动态组件的局部状态，提升到它的父组件（非动态加载的组件）中管理，通过 props 传递状态和修改状态的方法
  - 若状态需要跨多个组件共享，可将状态存入 Redux、MobX 或 React 的 Context 中。这样即使组件动态加载、重新挂载，也能从全局状态中获取最新数据
  - react router ：若状态和路由强相关，可将状态编码到 URL 的 query 参数或 path 中。路由切换时，通过解析 URL 恢复状态，避免丢失。

## 做组件复用过程中，是怎么设计组件的 props 来兼顾灵活性和扩展性
- props 可以用 TypeScript 接口拆分，将分成 核心部分，扩展部分，事件回调部分，再合并为一个props 使用
  比如：侧边栏组件，菜单数据闭传，而是否折叠，宽带等作为扩展
- props 也设定默认值，不传也默认
- 功能复杂的组件，可以拆分成多个组件，props 相对更小。比如：比如带筛选、排序、分页的列表组件，按照功能拆分更小

## 在实现 “响应式布局” 时，你是用媒体查询（@media）还是 CSS-in-JS 结合窗口监听，或者是用 UI 库的栅格系统？
- 在全局样式文件（如 global.css）中，预先定义不同环境的变量集合

### 比如组件需要根据父容器宽度而不是全局视口宽度做布局变化，这种情况你会怎么解决？
-  ResizeObserver + React状态管理： 对于需要根据父容器宽度变化的组件，我们会用ResizeObserver监听容器尺寸变化，然后通过React状态来控制布局
- 代码里有个sidebarWidth参数会传递给子组件，这就是为了让菜单项根据侧边栏实际宽度来调整显示方式。比如侧边栏很窄时，菜单文字会截断显示省略号。
- iframe内容的自适应： 对于嵌入的iframe应用，我们通过postMessage通信告诉子应用父容器的尺寸变化，让子应用做相应的布局调整

## API 工具
这个金额转换工具是我在前端开发中遇到分元转换精度问题后主导设计的通用解决方案。**技术实现上**，我选择了big.js库解决JavaScript浮点数精度丢失问题，设计了统一的API接口，支持多种舍入模式（截断、四舍五入、向上舍入），并通过完善的边缘case处理（空值、正负号、空格、异常输入）确保工具的健壮性。**开发流程上**，我采用TDD驱动开发，先编写27个测试用例覆盖各种业务场景，然后逐步实现功能，通过Jest进行持续测试，最终发布为npm包供团队使用。**业务价值方面**，这个工具解决了多个业务线分元转换逻辑不一致的痛点，避免了因精度问题导致的资损风险，提升了代码复用性和维护效率。目前已在公司内部多个项目中使用，减少了重复开发成本，统一了金额处理规范。整个项目体现了我在技术选型、API设计、测试驱动开发和工程化方面的综合能力。