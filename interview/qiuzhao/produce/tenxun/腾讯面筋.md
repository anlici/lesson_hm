18.比如说现在有一个网页，它打开的速度特别慢，你可能会通过什么方式去优化？
- 资源
  - 图片才用webp，图标svg
  - 懒加载，路由懒加载，图片懒加载，不重要的内容后续访问时再加载，
    可视区域加载，
- 网络：
  - http2 多路复用
  - CDN 最近节点访问，减少时间
  - 缓存，强缓存静态资源；协商缓存
- 代码：
  - 优化js，减少dom操作，defer异步，async ？
  - 首次内容加载速度 FCP

19.用户在前端需要执行一个计算密集型的任务（比如文件上传前的预处理、数据加密、图像处理等），这个计算过程很耗时，可能会阻塞UI，影响用户体验。怎么优化？
- web worker，重计算，开新线程，避免主线成阻塞，
- 缓存计算
- 异步，使用requestIdleCallback 再浏览器空闲时计算用户可能需要的任务
  大任务拆小任务，限制时间内，使用requestIdleCallback 执行计算任务，这里可以考虑优先级队列，

20.怎么让一个方法变为一个Promise？
- async 最常用
- new Promise() 构造函数，
```js
function readFilePromise(filename) {
    return new Promise((resolve, reject) => {
        readFile(filename, (error, data) => {
            if (error) {
                reject(error);
            } else {
                resolve(data);
            }
        });
    });
}
```

21.说下链表和数组的区别？
- 分配内存（数组连续，不管在堆还是站，）let bigArray = new Array(10000); // 肯定在堆中 
  let arr = [1, 2, 3]; // 可能在栈中，小数组
- 访问方式，适用地方（链表在于频繁修改，指针连接）
22.数组和链表他们随机访问一个元素，数组链表随机访问一个元素的时间复杂度是什么？
- 数组：O(1) 知道首地址和索引：首地址 + 索引 × 元素大小 就能找到
- 链表：O(n)
23.如果一个数组他们已经满了，我还要往里面插入元素要怎么做？
- 扩容，创建一个更大的新数组（通常是原来的2倍）
  不担心后面是否还有空间

24.什么叫原码补码？
- 原码：二进制,最高位表示符号位，0表示正数，1表示负数。
- 补码：
  正：原码，反码，补码相同；
  负数：反码取反，补码。 
25.补码用来解决什么问题？
- 负数计算，
26.为什么不直接使用原码？
- 原码需要考虑符号，运算时需要不同电路，硬件成本
  而补码直接相加，

- 移码，浮点数指数部分，补码符号位取反
乘法： 符号单独处理（异号为负，同号为正），数值部分用补码相乘
除法： 同样符号单独处理，数值部分用补码相除

27.了解过array的底层怎么实现的吗？
- 数组对象，
28.了解数组中的哪些方法？
- 遍历：forEach，map，filter，reduce，for of，for in
- 增删改：push，pop，shift，unshift，splice，
- 查：indexOf，includes，find，findIndex
- 排序：sort
- 拼接：concat，
- 截取：slice
- 反转：reverse
- 拷贝：slice，concat，spread
- 判断：isArray
- 填充：fill
- 迭代：entries，keys，values
- 空：isEmpty


29.map怎么实现？
- 内部遍历处理回调函数，返回新数组
- 底层是遍历器
30.Array.prototype.sort()怎么实现的？它是稳定的还是不稳定的？为什么不稳定？
- 早期V8使用快速排序： 快速排序本身是不稳定的算法（相对位置变化）
- 现代浏览器（V8引擎）：
小数组（≤10个元素）： 插入排序
大数组： TimSort（归并排序的优化版本）

31.说下HTTP的状态码，然后每个状态码对应的哪个意思？
- 1xx: 信息性状态码 101  切换协议，
- 2xx: 成功状态码 200 OK，204 No Content 没内容，
- 3xx: 重定向状态码 301 Moved Permanently 永久重定向，url 新的（请求方法可能get 变成post了 ），302 Found 临时重定向，
  304 Not Modified 缓存， 307 Temporary Redirect 临时重定向，url 不变
  308 Permanent Redirect 永久重定向，url 不变
- 4xx: 客户端错误状态码 400 Bad Request 请求错误，401 Unauthorized 未授权，403 Forbidden 禁止访问，404 Not Found 找不到，
- 5xx: 服务器错误状态码
  500 Internal Server Error 服务器错误，503 Service Unavailable 服务不可用

32.除了协商缓存还知道哪些缓存类型？
- 强缓存：Expires，Cache-Control
- 协商缓存：Last-Modified，ETag

33.知道哪些HTTP的请求头或者响应头？
- 请求头：get post 
- 响应头：content-type etag 
- 预检请求 = cors 机制
  对于复杂请求，除了get，post，head 以外，浏览器会先发送一个options 预检请求，
  判断是否支持跨域，服务器允许跨域后，浏览器才会发送真正的请求。`两倍 http 次数`
  `缓存预检请求，减少options 请求次数`
- http 2.0 通常需要https 一起使用？ 
34.跨域的问题怎么解决？
- JSONP
- CORS
- Nginx
- WebSocket
35.说下cookie和session的区别？
- Cookie是浏览器存储的小数据片段，每次请求都会自动带上；
  Session是服务器内存中的会话数据，通过SessionID来识别用户。
- 生命周期： Cookie可以设置过期时间持久保存，Session通常浏览器关闭就失效
性能影响： Cookie每次请求都传输增加网络开销，Session占用服务器内存
- 通常组合使用，Cookie存储SessionID，Session存储敏感的用户信息。
比如登录后，服务器创建Session存储用户数据，然后把SessionID通过Cookie发给浏览器，
后续请求浏览器自动带上这个SessionID，服务器就能找到对应的Session数据。

- MCP （model context protocol）统一大模型与外部数据源和工具之间的通信协议
  客户端请求，建立初步连接
  客户端发起需求，服务端响应，进行数据库或者第三方接口调用
  将结果返回给客户端，
  客户端接收结果，如果超时主动断开连接

- Function calling 函数调用，
  - 函数调用： 函数调用是函数调用另一个函数的过程。

36.什么叫加盐？
- 对密码加一个随机字符串，再hash处理。（做菜时加不同调料，同样的菜也会有不同味道）
37.对称加密和非对称加密有什么区别？
- 对称，相同回话密钥，直接传输数据。密钥分发问题
- 非对称，涉及证书验证通信，公钥加密，私钥解密
  解决了密钥分发问题但速度慢
38.HTTPS他是非对称加密还是对称加密？
- 混合加密
39.证书是什么东西？他起到一个什么样的作用？
- 权威机构颁发，客户端验证服务端身份，

40.手写map方法。
```js
const Map = (arr, callback) => {
    const res = [];
    for(let i = 0; i < arr.length; i++) {
        const value = callback.call(this,arr[i],i,arr);
        res.push(value);
    }
    return res;
}
```
41.算法：字符串的两数相加。（做太久了）
```js

```

- map 渲染key相同，
  React的diff算法依赖key来判断元素的身份。 相同的key让React误以为是同一个元素，
  只是内容变了，所以会复用DOM节点和组件状态，而不是创建新的。
- index 作为key 会导致性能问题，特别是当列表数据更新时，React需要重新渲染整个列表，
  即使只有个别元素的内容发生了变化。
  当没有增删改，或者末尾添加时，index作为key是安全的。

- useEffect 的作用
    用于处理“副作用”：与渲染无关、需要与外部系统交互的逻辑。
    常见场景：
    数据请求：发起/取消请求。
    订阅/事件：WebSocket、EventListener，且在清理函数中取消订阅。
    定时器：setInterval / setTimeout，并在清理中清除。
    操作浏览器 API：读写 document.title、测量 DOM、LocalStorage 同步等。
    依赖数组的语义：
    useEffect(fn, [])：仅首渲染后执行一次（以及卸载时清理）。
    useEffect(fn, [a, b])：当依赖变化时执行。
    无依赖数组：每次渲染后都执行。
    返回清理函数可在组件卸载或依赖变更前执行，防止泄漏。
    
- 对象更新useState 和函数式更新setState
  - 对象更新： 浅合并，
  状态依赖问题：当新状态依赖于前一次状态时，可能因闭包陷阱导致错误：

    方式2：使用展开运算符保留原有属性
    setState({ ...state, count: state.count + 1 });
  - 函数式更新： 执行函数，合并
    该函数接收前一次状态（prevState）和 props 作为参数：
    避免闭包陷阱：函数参数 prevState 始终指向最新的状态，解决状态依赖问题