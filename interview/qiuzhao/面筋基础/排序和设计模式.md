## 数组排序算法详解

### 1. 常见排序算法分类

**按时间复杂度分类：**
- **O(n²)**：冒泡排序（优化前最坏on2）、选择排序、插入排序
- **O(n log n)**：快速排序、归并排序、堆排序
- **O(n)**：计数排序、桶排序、基数排序（线性排序）

**按稳定性分类：**
- **稳定排序**：冒泡、插入、归并、计数、桶、基数
- **不稳定排序**：选择、快速、堆排序

### 2. 冒泡排序实现原理

**基本思想：**
通过相邻元素比较和交换，将最大元素逐步"冒泡"到数组末尾。

```javascript
// 基础冒泡排序实现
function bubbleSort(arr) {
  const len = arr.length;
  
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {
      // 相邻元素比较
      if (arr[j] > arr[j + 1]) {
        // 交换元素
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  
  return arr;
}
```

### 3. 冒泡排序优化方案 
**优化2：记录最后交换位置 以及交换标志（提前输出）**
```javascript
function bubbleSortOptimized2(arr) {
  const len = arr.length;
  let lastExchangeIndex = 0; // 最后一次交换的位置
  let sortBorder = len - 1;  // 无序数列的边界
  
  for (let i = 0; i < len - 1; i++) {
    let swapped = false;
    
    for (let j = 0; j < sortBorder; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        swapped = true;
        lastExchangeIndex = j;
      }
    }
    
    sortBorder = lastExchangeIndex;
    
    if (!swapped) {
      break;
    }
  }
  
  return arr;
}
```

```javascript
// 内置排序（通常是快速排序的优化版本）
arr.sort((a, b) => a - b); // O(n log n)

// 快速排序
function quickSort(arr) {
  if (arr.length <= 1) return arr;
  
  const pivot = arr[Math.floor(arr.length / 2)];
  const left = arr.filter(x => x < pivot);
  const middle = arr.filter(x => x === pivot);
  const right = arr.filter(x => x > pivot);
  
  return [...quickSort(left), ...middle, ...quickSort(right)];
}

// merge 是归并排序中的“合并”操作，用于将两个有序数组合并成一个有序数组。
// 归并排序的核心思想是“分而治之”：先递归拆分数组，最后通过 merge 合并有序子数组。
function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const left = mergeSort(arr.slice(0, mid));
  const right = mergeSort(arr.slice(mid));

  // merge 函数：合并两个有序数组
  function merge(left, right) {
    const result = [];
    let i = 0, j = 0;
    while (i < left.length && j < right.length) {
      if (left[i] <= right[j]) {
        result.push(left[i++]);
      } else {
        result.push(right[j++]);
      }
    }
    // 拼接剩余部分
    return result.concat(left.slice(i)).concat(right.slice(j));
  }

  return merge(left, right);
}
```

**总结：**
冒泡排序虽然简单，但在实际开发中很少使用。了解其原理有助于理解排序算法的基本思想，但在生产环境中应该选择更高效的排序算法。


## dfs 和 bfs 有啥运用场景？react 里面fiber 是基于那个？
### dfs VS bfs
- dfs 特典：
  - 递归：递归探索深层节点
  - 回溯：可撤销重新搜索 
- 场景：
  - 文件系统递归，查找子文件
- bfs 特典：
  - 队列管理，探索同层节点
  - 最短路径
- 场景：
  = 图最短路径
### fiber 递归dfs 转换为可中断迭代过程
- 执行完当前工作单元，返回下一个工作单元
- 先子节点处理完成后，处理兄弟节点，回溯到付节点
- 执行支持按时间达到后中断和

## 设计模式哪四种？分别运用场景？观察者【模式只是工具】
### 四种模式
- 1. 创建型模式
    `单例模式：全局状态管理、数据库连接池`
    `工厂模式：组件创建、插件系统`
    建造者模式：复杂对象构建、配置对象
- 2. 结构型模式
    适配器模式：API兼容、第三方库集成
    装饰器模式：功能扩展、中间件
    代理模式：缓存代理、权限控制
- 3. 行为型模式
    `观察者模式：事件系统、redux/vuex状态同步管理`
    策略模式：算法切换、表单验证
    命令模式：撤销重做、宏命令
- 4. 架构型模式
    MVC/MVVM：前端框架架构
    模块模式：代码组织、命名空间
    `发布订阅：组件通信、事件总线`

### 观察者模式 
- 一对多 依赖关系。当一个对象状态变化，所有依赖对象都会收到通知。
- 应用：
  - vue 响应式系统。data 变化，所以使用到data到组件都自动更新
  底层，通过proxy 拦截get/set 操作，在get收集依赖，set通知更新
  - 事件系统，用户点击按钮，可能多个组件响应
    按钮subject，其他组件observer
### 单利 VS 工厂
- 单利，确保全局只有一个实例。`单利用 闭包`，实例存在闭包里面，外部无法直接访问
  管理全局，保证唯一性，避免重复创建，比如，用户信息，应用配置
  维护使用模块模式，es6的import，或者map 管理多个单利
- 工厂，解决创建，比如组件库，根据type创建Button、Input、Modal等不同组件。
- 单利，考虑生命周期，避免内存泄漏。单例是全局唯一的，一旦创建就不会被垃圾回收
  比如数据库连接池，如果应用关闭时没有正确关闭连接，连接就会一直占用内存。
- 单利里面有定时器，事件监听，
  1，在构造函数里面写销毁方法，2，weakMap管理 当key被垃圾回收时，value也会被回收
  3，生命周期钩子关闭

### 发布订阅
- 完全解偶，发布者不知道谁在订阅，订阅者也不知道谁在发布。
    - 跨组件通信，用事件总线，登录组件发布'userLogin'事件，其他组件订阅就行。
    - 微前端通信，不同应用之间通过事件总线通信，避免直接依赖。
- 性能，异步处理，避免阻塞主线程。并且及时清理订阅，避免内存泄漏

先看问题本质：是要创建对象、管理状态、还是处理通信？
再看约束条件：性能要求、内存限制、团队熟悉度？
最后考虑维护性：代码是否清晰、是否容易扩展？
比如做状态管理，我优先考虑单例+观察者，因为简单可靠。做组件库，用工厂模式，因为要支持多种组件类型。

## a对象去访问b对象上面的方法或属性，怎么办？
- 1，a 继承 b，可以访问
- 2，原型链 a = Object.create(b) // a.__proto__ = b
    a.method(); // 通过原型链调用B的方法
## https 怎么实现更安全，非对称作用于什么数据？