9.怎么判断一个对象是不是这个类型。（instanceof）
9.1instanceof是如何判断的
9.2new里面的this指向什么
- instanceof 的原理是`检查右侧构造函数的 prototype 是否出现在左侧对象的原型链上`。
具体来说，A instanceof B 会沿着 A 的 proto 链向上查找，看是否能找到 B.prototype。
这也解释了为什么 new 操作符创建的实例中，this 指向新创建的对象，
因为 `new 会创建一个空对象，将其 proto 指向构造函数的 prototype，`
然后将构造函数的 this 绑定到这个新对象上执行

10.webpack和vite的区别 两者最大的区别在于`开发模式`的处理方式。
- Webpack 需要**先将所有模块打包成一个或者多个bundle.js** 再交给浏览器执行，
而 Vite 利用现代浏览器对 ES modules 的原生支持，**开发时直接让浏览器按需加载模块，vite 服务器实时编译并且返回**。
- 在热更新方面，`Webpack的HMR需要重新构建相关模块的依赖图，而Vite只需要让浏览器重新请求变更的模块`
Vite 底层使用 esbuild（Go 语言编写）进行依赖预构建和TS/JSX转换，比 Webpack 的 Node.js 实现快 10-100 倍。
- 生产环境两者都会打包，Vite使用Rollup，Webpack用自己的打包器，最终产物差异不大。

11.webpack的打包流程。如果要改文件，至少要在webpack的哪个流程前？
- 初始化阶段：读取配置文件，初始化Compiler对象
    编译准备：注册插件，创建Compilation对象
    模块构建：**从entry开始，递归解析依赖，构建模块依赖图**
    代码生成：将模块转换为可执行代码
    资源输出：根据配置将代码写入文件系统
- **需要修改内容时机**：写一个loader在模块构建时处理文件，或者写一个plugin在compilation的早期钩子中修改文件内容
  这就是为啥说loader负责文件转换，plugin负责功能扩展

12.事件编译题，script标签放在body的前面，script标签里面分别用同步，微任务，宏任务的方式获取document.body，打印的是什么
- 同步：undefined
- 微任务：null
- 宏任务：正常获取body 元素
【如果 script 标签在 body 前面，同步执行时 document.body 还未解析所以是 undefined；
微任务虽然在当前宏任务结束后执行，但此时 DOM 解析仍未完成，所以是 null；
宏任务会在下一个事件循环执行，此时 body 已解析完成，能正确获取到 body 元素。
这说明了为什么我们通常把 script 放在 body 底部或使用 defer/async 属性 】

13.浏览器解析到这个html文档，编译流程是什么。
- dom数和cssom树并行渲染，render 树
- 接着布局layout 计算每个元素位置和大小，
- 进行paint 绘制和composite 合成
- 在绘制阶段，浏览器会将页面分层进行光栅化，把矢量图转成像素点，合成显示屏幕上

14.dom树和CSSOM树是并行还是串行的
- **Render树的生成必须等待CSSOM树构建完成**，不阻塞dom解析，但阻塞页面
  渲染需要知道每个dom节点样式
15.重绘和回流，是哪个树发生了变化。 
- 当元素位置，隐藏，大小，重新layout计算 / 透明度，颜色，只需paint，
  render 树
16.如何主动启动GPU渲染。
- 创建`合成层`,但是有额外内存消耗
- `transform，opacity，will-change 属性`

17.如果想等文档加载完毕之后执行这个脚本，用什么（defer）
- defer 会等 DOM 解析完成后按顺序执行，适合依赖 DOM 的脚本；
  async 加载完立即执行，可能打断 DOM 解析，适合独立的第三方脚本

8.https什么时候用对称加密，什么时候用非对称加密
- 传递密钥，非对称；传递数据，对称
19.握手挥手时间不算，一共十个资源链接，每个资源的RTT（往返时间）是100ms，http1.0，1.1，2.0，3.0分别需要多少时间
- 1.0 每次都建立新tcp 连接，1000ms
- 1.1 有keep-alive连接复用，但是有对头阻塞，单个连接也是1000ms，
  实际浏览器开6-8个，10/6 * 1000 = 200ms
- 2.0 3.0 都多路复用，100ms

19.1http2的特性
19.2头部压缩用hpack，为什么要用hpack？hpack底层用哪种数据结构？压缩之后储存到哪里？
- hpack 头部压缩，解决http1.1 头部冗余问题。在http 请求头部信息可能是重复的
  减少每次传输带来带宽的浪费，
- hpack 底层用静态和动态表两种索引表结构，静态表按照协议规范定义，包含61个预定义常用头部字段，比如 method：get；
  动态索引表 fifo队列，存储连接期间未定义的字段，同时会用哈夫曼树进一步压缩字符串值
- 静态表存储在内存，动态在连接建立时初始化，存储在连接上下文，连接断开时清空；
  接收方根据索引号从静态表或动态表中查找对应的头部字段进行解码
19.3多路复用是如何实现？
- 在同一个TCP连接上，多个流可以并发传输，每个帧都带有流ID标识它属于哪个流。
接收端根据帧头中的流ID将帧重新组装成完整的HTTP消息
- 10个连接，虽然1.1 能keep-alive  复用连接，但每个连接都需要排队等待 
  2.0 每个连接可以并发多个流，每个流可以传输多个消息

19.4http3用的是UDP，如何保证之前的TCP的可用？
- http3 底层基于 UDP 实现，使用 QUIC 协议。
  quic 在应用层重新实现tcp 核心功能，也就相当udp 上重建了更好的tcp
- 数据包确认和重传：QUIC有自己的ACK机制，每个数据包都有序列号，接收方会发送确认帧，
  `发送方检测到丢包会进行重传`，这和TCP的机制类似但更高效。
- 拥塞控制：`QUIC内置了类似TCP的拥塞控制算法，能根据网络状况动态调整发送速率，避免网络拥塞`。
- 连接状态管理：QUIC维护连接状态，支持连接迁移（比如从WiFi切换到4G时连接不断开），这比TCP更强大。
- 流量控制：QUIC实现了连接级和流级的双重流量控制，通过WINDOW_UPDATE帧来管理发送窗口大小，防止接收方被数据淹没。

20.手撕，写一个数组扁平化，秒了。不让用迭代，不会。让加个depth，磕磕绊绊最后写出来了。
