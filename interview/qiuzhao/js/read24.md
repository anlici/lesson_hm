## es6新特性
- let const 变量声明，解决var声明变量的问题
- 解构赋值 （反转两者）
- 模板字符串  ${}
- 箭头函数 => （this 问题）解决普通函数 this 丢失问题
- 异步：Promise ，【比promise早点的：generator 迭代函数和yeild关键字（可yeild暂停返回一个值和next方法恢复执行）】
- 类 class 语法糖
- 模块化 import export

## 跨域情况，跨域a页面到b页面是否跨域
- 跨域，浏览器同源策略，核心目的是不允许不同源之间交换资源，防止恶意网站窃取用户数据
- 同源判断：协议（http/https）、域名（子域名）
  端口号
- 开发跨域：
  - 前端跑3000，后端跑8080
  - 

- a到a页面不跨域，
  a到b页面看情况：
  - 同域名不同路径，不垮
  - 不同子域名，跨
  - 不同协议，跨
### 跨域解决：
- vite 代理【vite 代理配置语法直观，proxy 配置
  esbuild 构建性能更好，启动快
  基于esm 热更新，更快的冷启动，热更新】
- cors 需要后端设定 ‘允许跨域的域，允许使用的方法，’
  前端
- nginx 反向代理，生产环境下，解决服务器跨域；
  能够隐藏真实地址，安全
- jsonp：只支持get，无法post等操作，
  依赖后端返回可执行的js代码，
  错误处理不行，404,500等没法做到

## 工程化
- 提升开发效率保证代码质量
- 包括：
    自动化构建：代码编译、打包、压缩
    模块化管理：依赖管理、代码分割
    开发体验：热更新、调试便利性（热更新）
    性能优化：Tree Shaking（vite和webpack都支持，通过ES模块的静态分析，自动移除未使用的代码）、懒加载
    质量保证：代码规范（eslint+ts）
### Webpack vs Vite 深度对比
```webpack
// Webpack的工作流程
入口文件 → 解析依赖 → 构建依赖图 → 打包所有模块 → 输出bundle

// 特点：
- 基于bundle的构建，所有代码打包成一个文件
- 开发时需要打包整个应用
- 热更新需要重新打包
- 配置复杂但功能强大
```
```vite
// Vite的工作流程
开发环境：ES模块直接加载 → 按需编译
生产环境：Rollup打包 → 优化输出

// 特点：
- 基于ES模块的开发服务器
- 按需编译，启动极快
- 原生ES模块热更新
- 配置简单，开箱即用

内置对 JSX 的支持，无需额外配置
```
### npm VS cnpm VS pnpm VS yarn
- npm 缺陷
  - 安装速度慢，解析依赖树后，可能重复下载相同依赖，
  - npm 可能下载两个版本依赖，版本冲突
  - 幽灵依赖，版本和依赖关系不明确
- pnpm 使用`符合链接`，避免幽灵依赖
  只要直接依赖被import，比如下载react 不会想着相关的lodash 
- yarn 锁定所有依赖版本，但是仍然会幽灵（明确安装某个东西，才能避免）
- cnpm 镜像
