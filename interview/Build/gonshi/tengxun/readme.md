## 两数之和，动态规划，防抖，异步编程
- 

## 为什么不直接操作虚拟 dom 若直接确定修改真实 dom 会不会比虚拟 dom 快
- 内存操作：虚拟dom 是内存中执行，但是真实dom 需要频繁和浏览器的渲染引擎打交道，速度慢
- 减少重绘重排：虚拟dom 更新，通过diff 算法，最更新变化部分，减少重绘重排，提高性能
  真实dom 每次重新计算，都会触发重绘重排，性能低
- 批量更新：虚拟dom 可以做一次性批量更新，减少多次渲染，提高性能；
  真实dom 只要修改了，立即触发重绘重排，性能低
- diff 算法：diff 算法很高效计算，

### 可能真实dom 会比虚拟dom 快
- 首次渲染，虚拟dom 需要先进行构建，再渲染，真实dom 直接渲染
- 简单的或很少的更新的，虚拟dom 需要diff 计算，真实dom 不需要


## 从登入请求到登入状态存储，到下次登入。

# vue 
## vue 响应式原理
- 数据劫持：vue 会对data 进行数据劫持，当数据发生变化时，会触发setter，通知视图更新
- 虚拟dom：vue 会将模板编译成虚拟dom，当数据发生变化时，会重新渲染虚拟dom，然后对比新旧虚拟dom，只更新变化的部分，减少重绘重排

## vue 组件间通信
- props：父组件向子组件传递数据
- $emit：子组件向父组件传递数据
- $attrs：子组件向父组件传递数据
- $refs：父组件获取子组件的实例
- provide/inject：父组件向子组件传递数据，但是子组件不能修改
- eventBus：vue 全局事件总线，父组件向子组件传递数据，子组件向父组件传递数据，但是子组件不能修改
- vuex：vuex 是一个状态管理器，用来管理应用中的状态，包括数据、逻辑和视图，
- vuex 的数据是响应式的，当数据发生变化时，会触发视图更新，但是 vuex 的数据是单例的，所以不能在子组件中修改 vuex 的数据，

## proxy 的监听原理有了解吗？
- 用于代理对象，可以拦截和自定义对象的基本操作，比如获取、设置、删除属性、调用方法等
- 过程：
  - 使用proxy 包裹一个原始需要被代理的对象
  - 注册副作用effect 函数，当原始对象发生变化时，会触发这个函数
  - 当副作用函数执行是，访问响应式对象的属性时，会触发getter，调用track 函数，将副作用函数添加到依赖集合中
  - 当修改响应式对象属性，，会触发setter，调用trigger 函数，遍历依赖集合，执行副作用函数
  - 当依赖集合中存在多个副作用函数时，会通过scheduler 函数，将多个副作用函数合并成一个，避免多次触发
- 与vue2 object.defineProperty 的区别：
  - proxy 可以监听数组的变化，不用额外处理
  - 监听对象添加、删除，执行更多操作，例如has、deleteProperty 等
  
### vue2 vue3 区别，升级优化
- vue2 采用选项式API，vue3 采用组合式API。组合式能更灵活，更易于维护,复用性更好
- vue3 采用proxy 响应式代理对象，vue2 采用object.defineProperty，
  proxy 能检测对象属性方添加和删除，性能更好；
  object.defineProperty 监听需要vue.set vue.delete 等方法，性能差
- vue3 在支持typescript 时，性能更好
- vue3 升级，重写虚拟dom，优化了diff 算法，
  支持tree-shaking，可以只打包需要的代码，体积更小
- 

## vite 为啥比webpack 快
- vite 采用esbuild 预构建，将依赖模块转换为esm 格式，
  浏览器可以直接解析，不需要打包，性能更好
- webpack 采用commonjs 模块化，需要全部打包整个模块，才能启动开发服务器，性能差
- 热更新：vite 只需要更新修改的模块，不需要全部打包，性能更好
  webpack 需要全部打包，需要重新编译，性能差

### webpack 打包流程
- 读取配置文件，创建compiler对象：
  Webpack会读取webpack.config.js配置文件，并根据配置创建一个compiler对象。compiler对象是Webpack的核心，负责整个打包过程的调度。
- 从入口文件开始，使用loader处理不同类型的文件：
  Webpack从配置中指定的入口文件开始，递归地解析所有依赖的模块。对于不同类型的文件（如CSS、图片等），Webpack会使用相应的loader进行处理，将其转换为JavaScript模块。
- 将所有模块转成js，解析模块之间的依赖关系，生成依赖图谱：
  Webpack会将所有模块转换为JavaScript代码，并解析模块之间的依赖关系，生成一个依赖图谱（Dependency Graph）。这个图谱描述了模块之间的依赖关系，是后续打包的基础。
- 在进行代码分隔，执行tree shaking，最后压缩代码，生成打包后的文件：
  Webpack会根据配置进行代码分隔（Code Splitting），将代码分割成多个块（chunk），以便按需加载。同时，Webpack会执行tree shaking，移除未使用的代码。最后，Webpack会对生成的代码进行压缩，以减小文件体积。
- 将打包后的文件输出到指定的目录：
  Webpack会将打包后的文件输出到配置中指定的目录，通常是dist目录。输出的文件包括JavaScript、CSS、图片等资源。

### vite 打包流程
- vite 使用esbuild 预构建依赖，不打包，直接使用浏览器原生的esm 模块，再****按需编译源文件**
  Vite在开发环境中利用esbuild进行依赖预构建，将依赖模块转换为ESM（ECMAScript Module）格式，浏览器可以直接解析这些模块，无需打包。
  Vite采用按需编译的方式，**只有在请求时才会编译源文件**，从而加快开发服务器的启动速度。
- 生产环境：使用rollup 打包，进行代码分隔。
  代码分隔策略包括：
    - 自动分割CSS：将CSS文件单独打包，便于按需加载。
    - 按路由分隔代码：根据路由动态加载代码，减少初始加载时间。
    - 可配置分隔策略：开发者可以根据需求自定义代码分隔规则。
- 代码切割：按照入口点分隔，不同入口生成不同包，使用es6 import（）动态导入模块，单独打包
  - Vite会根据入口点（entry points）将代码分割成多个包（chunks）。
  - 使用ES6的import()语法动态导入模块，这些模块会被单独打包，实现按需加载。
  - 多个入口共享的模块也会被单独打包，避免重复加载。
- 代码压缩：使用terser 压缩代码，去除无用代码，减少文件大小
- 代码预加载：使用preload 预加载模块，提高页面加载速度
  Vite通过<link rel="preload">标签预加载关键模块，确保这些模块在需要时已经加载完成，从而提升页面加载速度。
- 代码懒加载：使用lazy loading 懒加载模块，提高页面加载速度
  Vite支持懒加载（Lazy Loading），即只有在用户访问特定功能时才会加载相关模块，减少初始加载时间，优化用户体验


## http具体每一步是怎么请求的？https有什么特殊的处理？ssl怎么解析的？密匙怎么来的？
- http请求步骤：http（超文本传输协议）基于请求和响应的应用层协议，它定义了客户端如何请求服务器和服务器如何响应客户端的请求。
  - dns 解析：域名解析为ip地址。
    dns 查询：可能设计本地缓存、递归查询、和权威服务器等方式。
  - tcp 三次握手：
    客户端发送syn 包，
    服务器发送syn+ack 包，
    客户端发送ack 包，建立连接。
  - 发送http 请求:
    客户端发送http 请求，
    服务器处理请求，返回http 响应。
  - 关闭请求：
    http1.1 默认长连接，在同一个tcp 连接上，可以发送多个http 请求，
    http1.0 默认短连接，每个http 请求都需要建立一个tcp 连接。

- https 特殊处理：
  - 加密套件协商：
    客户端和服务器协商使用的加密算法（如 RSA、ECDHE）和哈希算法（如 SHA-256）。
  - 密钥交换：
    使用非对称加密（如 RSA 或 ECDHE）交换预主密钥。
    非对称加密用于密钥交换，对称加密用于后续通信。
  - 身份验证：
    服务器通过证书证明自己的身份。
    客户端通过验证证书链确认服务器的真实性。
  - 加密通信：
    双方使用协商好的对称加密算法和会话密钥进行加密通信。