## 两数之和，动态规划，异步编程
- 

## 为什么不直接操作虚拟 dom 若直接确定修改真实 dom 会不会比虚拟 dom 快
- 内存操作：虚拟dom 是内存中执行，但是真实dom 需要频繁和浏览器的渲染引擎打交道，速度慢
- 减少重绘重排：虚拟dom 更新，通过diff 算法，最更新变化部分，减少重绘重排，提高性能
  真实dom 每次重新计算，都会触发重绘重排，性能低
- 批量更新：虚拟dom 可以做一次性批量更新，减少多次渲染，提高性能；
  真实dom 只要修改了，立即触发重绘重排，性能低
- diff 算法：diff 算法很高效计算，

### 可能真实dom 会比虚拟dom 快
- 首次渲染，虚拟dom 需要先进行构建，再渲染，真实dom 直接渲染
- 简单的或很少的更新的，虚拟dom 需要diff 计算，真实dom 不需要

- 引导到自己会的内容上，不要慌张。
- 类组件和函数组件区别
  - class 继承，setState 状态（异步，在定时器或事件绑定 表现为同步）
  - 函数 js函数，useState ，可以使用useMemo，useCallback 优化
- setState 和 useState 区别
- setState 是否能 异步还是同步
- useRef useMemo
- 路由懒加载：组件打包一个js，现在懒加载，分隔多个独立代码块，按需加载；import 按需加载对应组件代码。
- debug 页面
- performance 面板：性能优化：页面加载时间、资源加载时间以及各种自定义的用户交互时间。
  - fp： 首次绘制时间，
  - fcp：首次内容绘制时间，首屏加载速度；
  - lcp： 视口最大元素，绘制时间
  - ttl： 页面加载总时间
  - domcontentloded：dom树解析完成时间
  

- **虚拟dom diff 算法，Reac和 vue区别**
  - vue diff ：基于节点类型，类型不同，直接替换；
    初次渲染标记静态节点，后续直接跳过这些节点，只渲染变化的节点；
  - react diff：基于组件层级结构，同一层节点不同，进行逐层比较。所有不同层级比较困难退化成o(n^2)
    key 属性优化队列渲染，

- 闭包原理，作用域，this 指向
- 事件捕获和事件冒泡区别和使用场景，react里面使用什么做事件捕获的
  合成机制，将捕获全给根节点，
- 节流函数，区别和使用场景
- 虚拟滚动原理
  只渲染可视区列表，非可视区不渲染；
  计算totalHeight 列表高度，触发滚动事件根据scrollTop 值更新开始和结束索引。startIndex 
  选择 Performance 工具，点击 Start 按钮，展开 Main 选项，会发现有很多红色的三角
- keepalive 底层怎么实现？
- 监听事件，怎么做addEventListener? 
  - 捕获阶段：如果将第三个参数设置为true，则事件监听器将在捕获阶段被调用
  - 通过**event.eventPhase属性**来判断当前事件的传播阶段
  - 事件类似，事件处理函数

- add 柯里化原理，
- 单页面和多页面区别，seo 考虑单页面不友好，怎么进行优化？
  - 单页面，只加载一次html，后续只加载数据，相当页面不是全部刷新
    但是seo 可能无法动态加载内容
  - 多页面，每次请求都加载一个新html。每个页面独立url。seo友好
  - 优化单页面：
    - ssr
    - 预渲染
    - 动态渲染，按照用户代理 判断请求来自爬虫还是用户，爬虫就给到静态html；

- localStorge 和 sessionStorge 区别，sessionStorge 存储的数据会话结束即失效，
  - localStorge 用户登入状态长期，主题切换，受到同源（协议，域名，端口）
  - sessionStorge 存储的数据会话结束即失效。同一个标签页，
  - indexdb 支持结构化数据，本地磁盘数据库，缓存离线文章

- 有用户，并发访问等
## 从登入请求到登入状态存储，到下次登入。
- 前端发送用户名和密码给后端：
  后端验证成功后，生成一个 JWT，并通过 Set-Cookie 设置 HttpOnly Cookie
  浏览器会存储这个 JWT，并在下次请求中发送给后端
  当用户再次打开网页时：
  浏览器自动携带 Cookie 到服务器
  后端解析 Token，验证有效性
  如果有效，返回用户信息，前端显示已登录状态。
  *登出，后端清除 Cookie，用户登出*。
- sessionId 是存放服务器的，后端提供http 响应头set-cookie 返回sessionId ，表面身份，防止xss 
- csrf ：跨站请求伪造，sameSite

# vue 
## vue 响应式原理
- 数据劫持：vue 会对data 进行数据劫持，当数据发生变化时，会触发setter，通知视图更新
- 虚拟dom：vue 会将模板编译成虚拟dom，当数据发生变化时，会重新渲染虚拟dom，然后对比新旧虚拟dom，只更新变化的部分，减少重绘重排

## vue 组件间通信
- props：父组件向子组件传递数据
- $emit：子组件向父组件传递数据
- $attrs：子组件向父组件传递数据
- $refs：父组件获取子组件的实例
- provide/inject：父组件向子组件传递数据，但是子组件不能修改
- eventBus：vue 全局事件总线，父组件向子组件传递数据，子组件向父组件传递数据，但是子组件不能修改
- vuex：vuex 是一个状态管理器，用来管理应用中的状态，包括数据、逻辑和视图，
- vuex 的数据是响应式的，当数据发生变化时，会触发视图更新，但是 vuex 的数据是单例的，所以不能在子组件中修改 vuex 的数据，

## proxy 的监听原理有了解吗？
- 用于代理对象，可以拦截和自定义对象的基本操作，比如获取、设置、删除属性、调用方法等
- 过程：
  - 使用proxy 包裹一个原始需要被代理的对象
  - 注册副作用effect 函数，当原始对象发生变化时，会触发这个函数
  - 当副作用函数执行是，访问响应式对象的属性时，会触发getter，调用track 函数，将副作用函数添加到依赖集合中
  - 当修改响应式对象属性，，会触发setter，调用trigger 函数，遍历依赖集合，执行副作用函数
  - 当依赖集合中存在多个副作用函数时，会通过scheduler 函数，将多个副作用函数合并成一个，避免多次触发
- 与vue2 object.defineProperty 的区别：
  - proxy 可以监听数组的变化，不用额外处理
  - 监听对象添加、删除，执行更多操作，例如has、deleteProperty 等
  
### vue2 vue3 区别，升级优化
- vue2 采用选项式API，vue3 采用组合式API。组合式能更灵活，更易于维护,复用性更好
- vue3 采用proxy 响应式代理对象，vue2 采用object.defineProperty，
  proxy 能检测对象属性方添加和删除，性能更好；
  object.defineProperty 监听需要vue.set vue.delete 等方法，性能差
- vue3 在支持typescript 时，性能更好
- vue3 升级，重写虚拟dom，优化了diff 算法，
  支持tree-shaking，可以只打包需要的代码，体积更小
- 

## vite 为啥比webpack 快
- vite 采用esbuild 预构建，将依赖模块转换为esm 格式，
  浏览器可以直接解析，不需要打包，性能更好
- webpack 采用commonjs 模块化，需要全部打包整个模块，才能启动开发服务器，性能差
- 热更新：vite 只需要更新修改的模块，不需要全部打包，性能更好
  webpack 需要全部打包，需要重新编译，性能差

### webpack 打包流程
- 读取配置文件，创建compiler对象：
  Webpack会读取webpack.config.js配置文件，并根据配置创建一个compiler对象。compiler对象是Webpack的核心，负责整个打包过程的调度。
- 从入口文件开始，*使用loader处理*不同类型的文件：
  Webpack从配置中指定的入口文件开始，递归地解析所有依赖的模块。对于不同类型的文件（如CSS、图片等），Webpack会使用相应的loader进行处理，将其转换为JavaScript模块。
- 将所有模块转成js，解析模块之间的依赖关系，生成依赖图谱：
  Webpack会将所有模块转换为JavaScript代码，并解析模块之间的依赖关系，生成一个依赖图谱（Dependency Graph）。这个图谱描述了模块之间的依赖关系，是后续打包的基础。
- 在进行代码分隔，执行tree shaking，最后压缩代码，生成打包后的文件：
  Webpack会根据配置进行代码分隔（Code Splitting），将代码分割成多个块（chunk），以便按需加载。同时，Webpack会执行tree shaking，移除未使用的代码。最后，Webpack会对生成的代码进行压缩，以减小文件体积。
- 将打包后的文件输出到指定的目录：
  Webpack会将打包后的文件输出到配置中指定的目录，通常是dist目录。输出的文件包括JavaScript、CSS、图片等资源。

## 优化webpack 打包
- 速度：使用多线程并行处理loader 任务；开启缓存编译结果，使用esbuild-loader 
- 体积：代码分隔，tree  shaking 移除未使用的代码，动态按需导入，图片压缩
- 热模块，无感刷新

### vite 打包流程
- vite 使用esbuild 预构建依赖，不打包，直接使用浏览器原生的esm 模块，再****按需编译源文件**
  Vite在开发环境中利用esbuild进行依赖预构建，将依赖模块转换为ESM（ECMAScript Module）格式，浏览器可以直接解析这些模块，无需打包。
  Vite采用按需编译的方式，**只有在请求时才会编译源文件**，从而加快开发服务器的启动速度。
- 生产环境：使用rollup 打包，进行代码分隔。
  代码分隔策略包括：
    - 自动分割CSS：将CSS文件单独打包，便于按需加载。
    - 按路由分隔代码：根据路由动态加载代码，减少初始加载时间。
    - 可配置分隔策略：开发者可以根据需求自定义代码分隔规则。
- 代码切割：按照入口点分隔，不同入口生成不同包，使用es6 import（）动态导入模块，单独打包
  - Vite会根据入口点（entry points）将代码分割成多个包（chunks）。
  - 使用ES6的import()语法动态导入模块，这些模块会被单独打包，实现按需加载。
  - 多个入口共享的模块也会被单独打包，避免重复加载。
- 代码压缩：使用terser 压缩代码，去除无用代码，减少文件大小
- 代码预加载：使用preload 预加载模块，提高页面加载速度
  Vite通过<link rel="preload">标签预加载关键模块，确保这些模块在需要时已经加载完成，从而提升页面加载速度。
- 代码懒加载：使用lazy loading 懒加载模块，提高页面加载速度
  Vite支持懒加载（Lazy Loading），即只有在用户访问特定功能时才会加载相关模块，减少初始加载时间，优化用户体验


## http具体每一步是怎么请求的？https有什么特殊的处理？ssl怎么解析的？密匙怎么来的？
- http请求步骤：http（超文本传输协议）基于请求和响应的应用层协议，它定义了客户端如何请求服务器和服务器如何响应客户端的请求。
  - dns 解析：域名解析为ip地址。
    dns 查询：可能设计本地缓存、递归查询、和权威服务器等方式。
  - tcp 三次握手：
    客户端发送syn 包，
    服务器发送syn+ack 包，
    客户端发送ack 包，建立连接。
  - 发送http 请求:
    客户端发送http 请求，
    服务器处理请求，返回http 响应。
  - 关闭请求：
    http1.1 默认长连接，在同一个tcp 连接上，可以发送多个http 请求，
    http1.0 默认短连接，每个http 请求都需要建立一个tcp 连接。

- https 特殊处理：
  - 加密套件协商：
    客户端和服务器协商使用的加密算法（如 RSA、ECDHE）和哈希算法（如 SHA-256）。
  - 密钥交换：
    使用非对称加密（如 RSA 或 ECDHE）交换预主密钥。
    非对称加密用于密钥交换，对称加密用于后续通信。
  - 身份验证：
    服务器通过证书证明自己的身份。
    客户端通过验证证书链确认服务器的真实性。
  - 加密通信：
    双方使用协商好的对称加密算法和会话密钥进行加密通信。
- Reac diff 区别，


- mpa 
- se
- useRef 
  useMemo 缓存 
  indexdb 
- 虚拟滚动
  react 
- addListening 
- null，立即执行函数；