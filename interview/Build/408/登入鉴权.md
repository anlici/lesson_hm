## jwt和cookies验证用户登录状态，这两的原理和优缺点
- jwt:服务器在用户登入后，生成一个包含用户信息的签名令牌，客户端存储令牌，后续请求时携带令牌，服务器验证令牌的有效性，从而判断用户的登录状态。
- cookies：服务器在用户登入成功后生成一个session id 存储在服务段，并且将这个session id 存储在set-cookie中，发送给客户端，客户端收到后，将这个session id 存储在cookies中，后续请求时，携带这个session id，服务器验证session id 的有效性，从而判断用户的登录状态。

- **cookie过程**：用户提交登录凭证；服务器验证后创建 session 记录；服务器返回响应并设置 Cookie；后续请求自动携带 Cookie；服务器验证 session ID 的有效性
- **jwt 过程**：用户提交登录凭证；服务器验证后生成 JWT；服务器返回 JWT 给客户端；客户端存储 JWT (通常在 localStorage 或 Cookie 中)；后续请求手动携带 JWT (通常在 Authorization 头部)；服务器验证 JWT 签名

- cookie 优点：可设置防止xss，可以随时使得session失效，存储在客户端，安全性高
  场景：存储量少，非敏感，需要http 自动携带发送服务
  *会话管理*（比如，购物车临时数据），用户偏好（前后端都可读取，统一渲染），状态跟踪
  敏感：进行加密 authorization 设置
- 缺点：crsf token 额外设置，受到同源影响，对部分移动不适合

- jwt： 跨域方便，服务器不要存会话信息，
- 缺点： 难以实现即时失效，通常需要短有效期+刷新令牌机制
- 刷新令牌：数据库存储，两个前端存
  - localStorge 受到xss  影响，请求头可能很大
  - 需要https 

- 通常混着用：
```js
// 示例：设置 JWT 到 HttpOnly Cookie
res.cookie('token', jwt, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'strict',
  maxAge: 1000 * 60 * 60 * 24 // 1天
});
```
- 推荐使用cookie，因为jwt 存储在localStorage 中，可能被xss 攻击，

## 刷新token
- 不让多个token 刷新，而是进行挂载任务
- （每个请求独立token 可能浪费资源，新token可能被后续 请求覆盖）
- 第一个发现问题的员工申请新卡，其他人在旁边等待。新卡到达后，所有人一起用同一张新卡进入。
- **封装工厂函数**，**做套子**每次调用，返回一个新的实例（多个模块相似）
- 封装对象逻辑，axios 拦截。如果使用单例，每个模块都共享同一个实例，可能执行冲突。a修改了实例，b也会修改实例。

## token 生成和下发
- 服务器加密生成token，通过http 响应体或者set-cookie 响应给前端
- axios 拦截器，请求头设置token；自动附加token
- 服务端返回 401 Unauthorized，前端通过 Refresh Token 或跳转登录页重新获取
- 内存变量放 高敏感，刷新后需要重新登入
- cookie 适用SSR，
  sessionStorage 会话级存储，单标签
- 如果需要持久化token，又不用cookie
  加密后存localStorge，crypto-js 
- X-CSRF-Token 后端设置csrf 预防；

前端：将用户输入的账号密码通过 HTTPS 发送到服务端。
服务端：验证密码后生成一个 短期有效的 Token（如 JWT） 返回给前端。（加盐哈
前端：存储这个 Token（而非密码），并在后续请求中携带它进行身份验证。
## koa 和express
- kao 双向 洋葱，ctx 封装req/res,next 调用下一个中间件，
- **中间层**，关注：
  - 错误日志，
  - next 执行顺序
  - jwt 鉴权
  - 跨域 acces-control-allow-origin， cors头

## 跨域解决
- 开发环境：
- vite 内置http-proxy 代理功能，无需依赖jsonp，或者手动配置cors
  在vite.config.js 中添加如下代码
- 手动cors 配置：allow-origin: '*'，methods，headers
- jsonp：只支持get，无法post等操作，
  依赖后端返回可执行的js代码，
  错误处理不行，404,500等没法做到
- 生成环境：
  - nginx 反向代理，服务器解决跨域；隐藏真实地址，安全
- cors 也行，但不用通配符 *，

## 单例，工厂
- 单例：一个类只有一个实例，全局共享（全局访问点）
  被访问时候创建实例

## 输出顺序是什么？
function app() {
    
    promise.resolve().then(() => {
        console.log('promise')
    })
    useEffect(() => {
        console.log('useEffect')
    }, [count])
    useLayoutEffect(() => {
        console.log('useLayoutEffect')
    }, [count])

    return (
        <div>
            <h1>{count}</h1>
        </div> 
    )
}
// useLayoutEffect ->  promise -> useEffect
- DOM 更新后立即执行，且会阻塞浏览器的绘制，确保在浏览器绘制之前完成所有的布局和绘制相关的操作。
- 浏览器绘制之后，因此它的执行会在 useLayoutEffect 和微任务之后
- useLayoutEffect 和 useEffect 的区别：
  - useLayoutEffect 同步，避免视觉闪烁，useEffect 异步，不会阻塞浏览器绘制。
  - 优先useEffect，副作用不用立即，或不涉及dom操作
  