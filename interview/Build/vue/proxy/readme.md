## reactive 和 ref 响应式的区别
- Vue3 中的 reactive 是基于 ES6 的 Proxy 代理实现的响应式系统。它*专门用于处理引用类型数据（如对象或数组），通过拦截对象属性的访问和修改操作实现响应式*。具体工作原理是：**当我们访问对象属性时，会触发 Proxy 的 get 陷阱（trap），此时进行依赖收集，将当前正在执行的副作用函数（effect）与该属性关联起来；当我们修改对象属性时，会触发 Proxy 的 set 陷阱，系统会通知所有依赖于该属性的副作用函数重新执行，从而实现界面的自动更新**。reactive 的局限性在于它只能处理对象类型，不能直接代理原始类型值。

- ref 是 Vue3 提供的另一种响应式解决方案，它可以处理任何类型的数据，包括原始类型（如数字、字符串、布尔值等）和引用类型。当我们使用 ref 包装一个原始类型值时，它**会创建一个带有 value 属性的 RefImpl 对象**，并通过 Object.defineProperty 的 get/set 拦截器实现这个 value 属性的响应式。当我们使用 **ref 包装一个引用类型值时，它会在内部调用 reactive 来处理这个值，然后将其包装在 RefImpl 对象的 value 属性中**。这就是为什么使用 ref 时需要通过 .value 访问或修改值的原因。*在模板中使用 ref 时，Vue 会自动解包，不需要手动添加 .value*。

## vue 响应式的实现原理
- vue3 基于Proxy 实现数据劫持，结合依赖收集和派发更新，实现了响应式数据。
- 提供reactive 和 ref api，方便我们创建响应式数据。
- 工作流程：
  - 组件初始化，渲染函数被包装成副作用函数，并调用执行。
  - 渲染工程访问响应式数据，触发get 操作，进行依赖收集。
  - 响应式数据发生变化，触发set 操作，通知依赖更新。
  - 重新执行渲染函数，生成新的虚拟dom，
  - 通过diff 算法，比较新旧虚拟dom，更新视图。

## computed  和 watch 的区别
- 都是用于响应式数据变化
- computed 是计算属性，会自动追踪自身内部使用的响应式数据，并且在组件初始化是执行一次，会返回一个值。并且值会缓存，只要当依赖的响应式数据变化时，会重新计算。
- watch 是侦听器，用于监听指定数据源的变化，每次数据变化时执行回调函数，处理副作用或自定义逻辑。
- watch 可以监听单个或多个数据源，可以使用immediate 和deep 选项控制回调函数的执行时机。
- 其实如果多个数据源，使用watchEffect 就可以了。
- 使用场景：
  - computed  过滤、
  - watch 数据请求、dom操作
- watch 类似useEffect，useEffect 通过依赖数组，需要手动实现深度监听


## 模块化怎么设计？
- 在项目中，将每个页面、组件、工具函数、api请求等拆分成独立模块，使用es6 中import/export 语法进行模块化, 提高代码的可维护性和可复用性。
- 通过按功能拆分，明确模块接口，使用模块化机制实现自动管理依赖
- es6，静态分析，支持tree shaking 优化。